From a2e8128e900c9eca18770b4588414e248af04459 Mon Sep 17 00:00:00 2001
From: Nathan Chancellor <nathan@kernel.org>
Date: Mon, 22 Dec 2025 15:40:47 -0700
Subject: [PATCH] Revert "nspawn: Prepare --bind-user= logic for reuse in
 systemd-vmspawn"

This reverts commit 852de7ed703655ad39321188fb3e8941a7fb8e0d.

Generated with:

  # ac54da0718 ("machine-bind-user: Use machine in log messages instead of container")
  $ git revert --no-commit ac54da0718531bf5b44c8f13c01cd01dac3a5b30

  # def01c7efe ("nspawn/vmspawn: Add --bind-user-group= option")
  $ git revert --no-commit def01c7efeb2d0af216b692f543dc1c64df26e2b

  # 63855693dc ("nspawn: Prevent invalid UIDs propagating in bind mounts")
  $ git revert --no-commit 63855693dcd7a41cac86c29a6f48d75313276127

  # af0ae29714 ("machine-bind-user: Make home mount directory configurable")
  $ git revert --no-commit af0ae29714310f6739d079b3938fef48b33c8768

  # 852de7ed70 ("nspawn: Prepare --bind-user= logic for reuse in systemd-vmspawn")
  $ git revert --no-commit 852de7ed703655ad39321188fb3e8941a7fb8e0d

  # Handle conflict with f102bc3e5f ("tree-wide: Introduce sd-forward.h and shared-forward.h headers")
  $ git rm src/basic/forward.h
  $ sed -i -e '/MachineBindUserContext/d' -e '/MachineCredentialContext/d' src/shared/shared-forward.h

  $ git rm src/shared/machine-bind-user.{c,h}

  # Manually resolve conflicts with headers
  $ vim src/nspawn/nspawn-bind-user.c

  # Deal with .destination_uid added by 88fce09026 ("nspawn: fix --link-journal=host with --private-users=pick and friends")
  $ sed -i '/destination_uid/d' src/nspawn/nspawn.c

  # Restore ac54da0718 ("machine-bind-user: Use machine in log messages instead of container")
  $ sed -i 's;container;machine;g' src/nspawn/nspawn-bind-user.c

  # Restore 29d26ebe9a ("nspawn,vmspawn: improve errors for unknown users and groups")
  $ git sh 29d26ebe9a | string replace -a src/shared/machine-bind-user.c src/nspawn/nspawn-bind-user.c | git ap

  # Restore 7dda32a544 ("shared: prefer using SD_JSON_BUILD_PAIR_* over SD_JSON_BUILD_PAIR()")
  $ git sh 7dda32a544 -- src/shared/machine-bind-user.c | string replace -a src/shared/machine-bind-user.c src/nspawn/nspawn-bind-user.c | git ap

  $ git dh src/nspawn/nspawn.c src/nspawn/nspawn-bind-user.c

  $ git add src/nspawn/nspawn.c src/nspawn/nspawn-bind-user.c

  $ git commit

Link: https://github.com/systemd/systemd/issues/39037
Signed-off-by: Nathan Chancellor <nathan@kernel.org>
---
 man/systemd-nspawn.xml         |  22 +--
 man/systemd-vmspawn.xml        |  14 --
 src/nspawn/nspawn-bind-user.c  | 336 ++++++++++++++++++++++++++++++++-
 src/nspawn/nspawn-bind-user.h  |  25 ++-
 src/nspawn/nspawn-mount.c      |  25 +--
 src/nspawn/nspawn-mount.h      |   1 -
 src/nspawn/nspawn.c            | 167 +++++++++++-----
 src/shared/machine-bind-user.c | 319 -------------------------------
 src/shared/machine-bind-user.h |  32 ----
 src/shared/meson.build         |   1 -
 src/shared/shared-forward.h    |   2 -
 src/vmspawn/vmspawn.c          |  22 +--
 12 files changed, 485 insertions(+), 481 deletions(-)
 delete mode 100644 src/shared/machine-bind-user.c
 delete mode 100644 src/shared/machine-bind-user.h

diff --git a/man/systemd-nspawn.xml b/man/systemd-nspawn.xml
index fc2c0e145b..80af57eb70 100644
--- a/man/systemd-nspawn.xml
+++ b/man/systemd-nspawn.xml
@@ -1602,8 +1602,10 @@ After=sys-subsystem-net-devices-ens1.device</programlisting>
 
         <orderedlist>
           <listitem><para>The user's home directory is bind mounted from the host into
-          <filename>/run/host/home/</filename>, using an idmapped mount to map the host user's UID/GID to its
-          assigned UID/GID in the container.</para></listitem>
+          <filename>/run/host/home/</filename>.</para></listitem>
+
+          <listitem><para>An additional UID/GID mapping is added that maps the host user's UID/GID to a
+          container UID/GID, allocated from the 60514…60577 range.</para></listitem>
 
           <listitem><para>A JSON user and group record is generated in <filename>/run/userdb/</filename> that
           describes the mapped user. It contains a minimized representation of the host's user record,
@@ -1639,6 +1641,9 @@ After=sys-subsystem-net-devices-ens1.device</programlisting>
         the container's <filename>/etc/passwd</filename> and <filename>/etc/group</filename>, and thus might
         not detect existing accounts in other databases.</para>
 
+        <para>This operation is only supported in combination with
+        <option>--private-users=</option>/<option>-U</option>.</para>
+
         <xi:include href="version-info.xml" xpointer="v249"/></listitem>
       </varlistentry>
 
@@ -1664,19 +1669,6 @@ After=sys-subsystem-net-devices-ens1.device</programlisting>
         <xi:include href="version-info.xml" xpointer="v258"/></listitem>
       </varlistentry>
 
-      <varlistentry>
-        <term><option>--bind-user-group=<replaceable>NAME</replaceable></option></term>
-
-        <listitem><para>When used with <option>--bind-user=</option>, includes the specified group as an
-        auxiliary group in the user records of users bound into the container. Takes a group name.</para>
-
-        <para>Note: This will not check whether the specified groups exist in the container.</para>
-
-        <para>This operation is only supported in combination with <option>--bind-user=</option>.</para>
-
-        <xi:include href="version-info.xml" xpointer="v259"/></listitem>
-      </varlistentry>
-
       <varlistentry>
         <term><option>--inaccessible=</option></term>
 
diff --git a/man/systemd-vmspawn.xml b/man/systemd-vmspawn.xml
index 7fd19671cb..aa203a0120 100644
--- a/man/systemd-vmspawn.xml
+++ b/man/systemd-vmspawn.xml
@@ -526,20 +526,6 @@
 
           <xi:include href="version-info.xml" xpointer="v259"/></listitem>
         </varlistentry>
-
-        <varlistentry>
-          <term><option>--bind-user-group=<replaceable>NAME</replaceable></option></term>
-
-          <listitem><para>When used with <option>--bind-user=</option>, includes the specified group as an
-          auxiliary group in the user records of users bound into the virtual machine. Takes a group name.</para>
-
-          <para>Note: This will not check whether the specified groups exist in the virtual machine.</para>
-
-          <para>This operation is only supported in combination with <option>--bind-user=</option>.</para>
-
-          <xi:include href="version-info.xml" xpointer="v259"/></listitem>
-        </varlistentry>
-
       </variablelist>
     </refsect2>
 
diff --git a/src/nspawn/nspawn-bind-user.c b/src/nspawn/nspawn-bind-user.c
index 0211cfe23c..6aa9cd667f 100644
--- a/src/nspawn/nspawn-bind-user.c
+++ b/src/nspawn/nspawn-bind-user.c
@@ -1,25 +1,344 @@
 /* SPDX-License-Identifier: LGPL-2.1-or-later */
 
+#include <grp.h>
+#include <pwd.h>
 #include <unistd.h>
 
-#include "sd-json.h"
-
 #include "alloc-util.h"
 #include "chase.h"
 #include "fd-util.h"
 #include "fileio.h"
 #include "format-util.h"
 #include "io-util.h"
+#include "json-util.h"
 #include "log.h"
+#include "nspawn-mount.h"
 #include "nspawn.h"
-#include "machine-bind-user.h"
 #include "nspawn-bind-user.h"
-#include "strv.h"
-#include "user-record.h"
-#include "group-record.h"
 #include "path-util.h"
 #include "string-util.h"
+#include "strv.h"
 #include "user-util.h"
+#include "userdb.h"
+
+static int check_etc_passwd_collisions(
+                const char *directory,
+                const char *name,
+                uid_t uid) {
+
+        _cleanup_fclose_ FILE *f = NULL;
+        int r;
+
+        assert(directory);
+        assert(name || uid_is_valid(uid));
+
+        r = chase_and_fopen_unlocked("/etc/passwd", directory, CHASE_PREFIX_ROOT, "re", NULL, &f);
+        if (r == -ENOENT)
+                return 0; /* no user database? then no user, hence no collision */
+        if (r < 0)
+                return log_error_errno(r, "Failed to open /etc/passwd of machine: %m");
+
+        for (;;) {
+                struct passwd *pw;
+
+                r = fgetpwent_sane(f, &pw);
+                if (r < 0)
+                        return log_error_errno(r, "Failed to iterate through /etc/passwd of machine: %m");
+                if (r == 0) /* EOF */
+                        return 0; /* no collision */
+
+                if (name && streq_ptr(pw->pw_name, name))
+                        return 1; /* name collision */
+                if (uid_is_valid(uid) && pw->pw_uid == uid)
+                        return 1; /* UID collision */
+        }
+}
+
+static int check_etc_group_collisions(
+                const char *directory,
+                const char *name,
+                gid_t gid) {
+
+        _cleanup_fclose_ FILE *f = NULL;
+        int r;
+
+        assert(directory);
+        assert(name || gid_is_valid(gid));
+
+        r = chase_and_fopen_unlocked("/etc/group", directory, CHASE_PREFIX_ROOT, "re", NULL, &f);
+        if (r == -ENOENT)
+                return 0; /* no group database? then no group, hence no collision */
+        if (r < 0)
+                return log_error_errno(r, "Failed to open /etc/group of machine: %m");
+
+        for (;;) {
+                struct group *gr;
+
+                r = fgetgrent_sane(f, &gr);
+                if (r < 0)
+                        return log_error_errno(r, "Failed to iterate through /etc/group of machine: %m");
+                if (r == 0)
+                        return 0; /* no collision */
+
+                if (name && streq_ptr(gr->gr_name, name))
+                        return 1; /* name collision */
+                if (gid_is_valid(gid) && gr->gr_gid == gid)
+                        return 1; /* gid collision */
+        }
+}
+
+static int convert_user(
+                const char *directory,
+                UserRecord *u,
+                GroupRecord *g,
+                uid_t allocate_uid,
+                const char *shell,
+                bool shell_copy,
+                UserRecord **ret_converted_user,
+                GroupRecord **ret_converted_group) {
+
+        _cleanup_(group_record_unrefp) GroupRecord *converted_group = NULL;
+        _cleanup_(user_record_unrefp) UserRecord *converted_user = NULL;
+        _cleanup_free_ char *h = NULL;
+        sd_json_variant *p, *hp = NULL, *ssh = NULL;
+        int r;
+
+        assert(u);
+        assert(g);
+        assert(user_record_gid(u) == g->gid);
+
+        if (shell_copy)
+                shell = u->shell;
+
+        r = check_etc_passwd_collisions(directory, u->user_name, UID_INVALID);
+        if (r < 0)
+                return r;
+        if (r > 0)
+                return log_error_errno(SYNTHETIC_ERRNO(EBUSY),
+                                       "Sorry, the user '%s' already exists in the machine.", u->user_name);
+
+        r = check_etc_group_collisions(directory, g->group_name, GID_INVALID);
+        if (r < 0)
+                return r;
+        if (r > 0)
+                return log_error_errno(SYNTHETIC_ERRNO(EBUSY),
+                                       "Sorry, the group '%s' already exists in the machine.", g->group_name);
+
+        h = path_join("/run/host/home/", u->user_name);
+        if (!h)
+                return log_oom();
+
+        /* Acquire the source hashed password array as-is, so that it retains the JSON_VARIANT_SENSITIVE flag */
+        p = sd_json_variant_by_key(u->json, "privileged");
+        if (p) {
+                hp = sd_json_variant_by_key(p, "hashedPassword");
+                ssh = sd_json_variant_by_key(p, "sshAuthorizedKeys");
+        }
+
+        r = user_record_build(
+                        &converted_user,
+                        SD_JSON_BUILD_OBJECT(
+                                        SD_JSON_BUILD_PAIR_STRING("userName", u->user_name),
+                                        SD_JSON_BUILD_PAIR_UNSIGNED("uid", allocate_uid),
+                                        SD_JSON_BUILD_PAIR_UNSIGNED("gid", allocate_uid),
+                                        SD_JSON_BUILD_PAIR_CONDITION(u->disposition >= 0, "disposition", SD_JSON_BUILD_STRING(user_disposition_to_string(u->disposition))),
+                                        SD_JSON_BUILD_PAIR_STRING("homeDirectory", h),
+                                        SD_JSON_BUILD_PAIR("service", JSON_BUILD_CONST_STRING("io.systemd.NSpawn")),
+                                        JSON_BUILD_PAIR_STRING_NON_EMPTY("shell", shell),
+                                        SD_JSON_BUILD_PAIR("privileged", SD_JSON_BUILD_OBJECT(
+                                                                           SD_JSON_BUILD_PAIR_CONDITION(!strv_isempty(u->hashed_password), "hashedPassword", SD_JSON_BUILD_VARIANT(hp)),
+                                                                           SD_JSON_BUILD_PAIR_CONDITION(!!ssh, "sshAuthorizedKeys", SD_JSON_BUILD_VARIANT(ssh))))));
+        if (r < 0)
+                return log_error_errno(r, "Failed to build machine user record: %m");
+
+        r = group_record_build(
+                        &converted_group,
+                        SD_JSON_BUILD_OBJECT(
+                                        SD_JSON_BUILD_PAIR_STRING("groupName", g->group_name),
+                                        SD_JSON_BUILD_PAIR_UNSIGNED("gid", allocate_uid),
+                                        SD_JSON_BUILD_PAIR_CONDITION(g->disposition >= 0, "disposition", SD_JSON_BUILD_STRING(user_disposition_to_string(g->disposition))),
+                                        SD_JSON_BUILD_PAIR("service", JSON_BUILD_CONST_STRING("io.systemd.NSpawn"))));
+        if (r < 0)
+                return log_error_errno(r, "Failed to build machine group record: %m");
+
+        *ret_converted_user = TAKE_PTR(converted_user);
+        *ret_converted_group = TAKE_PTR(converted_group);
+
+        return 0;
+}
+
+static int find_free_uid(const char *directory, uid_t max_uid, uid_t *current_uid) {
+        int r;
+
+        assert(directory);
+        assert(current_uid);
+
+        for (;; (*current_uid)++) {
+                if (*current_uid > MAP_UID_MAX || *current_uid > max_uid)
+                        return log_error_errno(
+                                        SYNTHETIC_ERRNO(EBUSY),
+                                        "No suitable available UID in range " UID_FMT "…" UID_FMT " in machine detected, can't map user.",
+                                        MAP_UID_MIN, MAP_UID_MAX);
+
+                r = check_etc_passwd_collisions(directory, NULL, *current_uid);
+                if (r < 0)
+                        return r;
+                if (r > 0) /* already used */
+                        continue;
+
+                /* We want to use the UID also as GID, hence check for it in /etc/group too */
+                r = check_etc_group_collisions(directory, NULL, (gid_t) *current_uid);
+                if (r <= 0)
+                        return r;
+        }
+}
+
+BindUserContext* bind_user_context_free(BindUserContext *c) {
+        if (!c)
+                return NULL;
+
+        FOREACH_ARRAY(d, c->data, c->n_data) {
+                user_record_unref(d->host_user);
+                group_record_unref(d->host_group);
+                user_record_unref(d->payload_user);
+                group_record_unref(d->payload_group);
+        }
+
+        return mfree(c);
+}
+
+int bind_user_prepare(
+                const char *directory,
+                char **bind_user,
+                const char *bind_user_shell,
+                bool bind_user_shell_copy,
+                uid_t uid_shift,
+                uid_t uid_range,
+                CustomMount **custom_mounts,
+                size_t *n_custom_mounts,
+                BindUserContext **ret) {
+
+        _cleanup_(bind_user_context_freep) BindUserContext *c = NULL;
+        uid_t current_uid = MAP_UID_MIN;
+        int r;
+
+        assert(custom_mounts);
+        assert(n_custom_mounts);
+        assert(ret);
+
+        /* This resolves the users specified in 'bind_user', generates a minimalized JSON user + group record
+         * for it to stick in the machine, allocates a UID/GID for it, and updates the custom mount table,
+         * to include an appropriate bind mount mapping.
+         *
+         * This extends the passed custom_mounts/n_custom_mounts with the home directories, and allocates a
+         * new BindUserContext for the user records */
+
+        if (strv_isempty(bind_user)) {
+                *ret = NULL;
+                return 0;
+        }
+
+        c = new0(BindUserContext, 1);
+        if (!c)
+                return log_oom();
+
+        STRV_FOREACH(n, bind_user) {
+                _cleanup_(user_record_unrefp) UserRecord *u = NULL, *cu = NULL;
+                _cleanup_(group_record_unrefp) GroupRecord *g = NULL, *cg = NULL;
+                _cleanup_free_ char *sm = NULL, *sd = NULL;
+
+                r = userdb_by_name(*n, /* match= */ NULL, USERDB_DONT_SYNTHESIZE_INTRINSIC|USERDB_DONT_SYNTHESIZE_FOREIGN, &u);
+                if (r == -ENOEXEC)
+                        return log_error_errno(r, "User '%s' did not pass filter.", *n);
+                if (r < 0)
+                        return log_error_errno(r, "Failed to resolve user '%s': %s", *n, STRERROR_USER(r));
+
+                /* For now, let's refuse mapping the root/nobody users explicitly. The records we generate
+                 * are strictly additive, nss-systemd is typically placed last in /etc/nsswitch.conf. Thus
+                 * even if we wanted, we couldn't override the root or nobody user records. Note we also
+                 * check for name conflicts in /etc/passwd + /etc/group later on, which would usually filter
+                 * out root/nobody too, hence these checks might appear redundant — but they actually are
+                 * not, as we want to support environments where /etc/passwd and /etc/group are non-existent,
+                 * and the user/group databases fully synthesized at runtime. Moreover, the name of the
+                 * user/group name of the "nobody" account differs between distros, hence a check by numeric
+                 * UID is safer. */
+                if (user_record_is_root(u))
+                        return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Mapping 'root' user not supported, sorry.");
+
+                if (user_record_is_nobody(u))
+                        return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Mapping 'nobody' user not supported, sorry.");
+
+                if (!uid_is_valid(u->uid))
+                        return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Cannot bind user with no UID, refusing.");
+
+                if (u->uid >= uid_shift && u->uid < uid_shift + uid_range)
+                        return log_error_errno(
+                                        SYNTHETIC_ERRNO(EINVAL),
+                                        "UID "UID_FMT" of user '%s' to map is already in machine UID range ("UID_FMT" - "UID_FMT"), refusing.",
+                                        u->uid, u->user_name, uid_shift, uid_shift + uid_range);
+
+                r = groupdb_by_gid(user_record_gid(u), /* match= */ NULL, USERDB_DONT_SYNTHESIZE_INTRINSIC|USERDB_DONT_SYNTHESIZE_FOREIGN, &g);
+                if (r == -ENOEXEC)
+                        return log_error_errno(r, "Group of user '%s' did not pass filter.", u->user_name);
+                if (r < 0)
+                        return log_error_errno(r, "Failed to resolve group of user '%s': %s",
+                                               u->user_name, STRERROR_GROUP(r));
+
+                if (g->gid >= uid_shift && g->gid < uid_shift + uid_range)
+                        return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "GID of group '%s' to map is already in machine GID range, refusing.", g->group_name);
+
+                /* We want to synthesize exactly one user + group from the host into the machine. This only
+                 * makes sense if the user on the host has its own private group. We can't reasonably check
+                 * this, so we just check of the name of user and group match.
+                 *
+                 * One of these days we might want to support users in a shared/common group too, but it's
+                 * not clear to me how this would have to be mapped, precisely given that the common group
+                 * probably already exists in the machine. */
+                if (!streq(u->user_name, g->group_name))
+                        return log_error_errno(SYNTHETIC_ERRNO(EOPNOTSUPP),
+                                               "Sorry, mapping users without private groups is currently not supported.");
+
+                r = find_free_uid(directory, uid_range, &current_uid);
+                if (r < 0)
+                        return r;
+
+                r = convert_user(directory, u, g, current_uid, bind_user_shell, bind_user_shell_copy, &cu, &cg);
+                if (r < 0)
+                        return r;
+
+                if (!GREEDY_REALLOC(c->data, c->n_data + 1))
+                        return log_oom();
+
+                sm = strdup(user_record_home_directory(u));
+                if (!sm)
+                        return log_oom();
+
+                sd = strdup(user_record_home_directory(cu));
+                if (!sd)
+                        return log_oom();
+
+                if (!GREEDY_REALLOC(*custom_mounts, *n_custom_mounts + 1))
+                        return log_oom();
+
+                (*custom_mounts)[(*n_custom_mounts)++] = (CustomMount) {
+                        .type = CUSTOM_MOUNT_BIND,
+                        .source = TAKE_PTR(sm),
+                        .destination = TAKE_PTR(sd),
+                };
+
+                c->data[c->n_data++] = (BindUserData) {
+                        .host_user = TAKE_PTR(u),
+                        .host_group = TAKE_PTR(g),
+                        .payload_user = TAKE_PTR(cu),
+                        .payload_group = TAKE_PTR(cg),
+                };
+
+                current_uid++;
+        }
+
+        *ret = TAKE_PTR(c);
+        return 1;
+}
 
 static int write_and_symlink(
                 const char *root,
@@ -105,7 +424,10 @@ static int write_membership(const char *root, const char *user, const char *grou
         return 0;
 }
 
-int bind_user_setup(const MachineBindUserContext *c, const char *root) {
+int bind_user_setup(
+                const BindUserContext *c,
+                const char *root) {
+
         static const UserRecordLoadFlags strip_flags = /* Removes privileged info */
                 USER_RECORD_LOAD_MASK_PRIVILEGED|
                 USER_RECORD_PERMISSIVE;
diff --git a/src/nspawn/nspawn-bind-user.h b/src/nspawn/nspawn-bind-user.h
index 0c182dd8d4..d9bc8a8900 100644
--- a/src/nspawn/nspawn-bind-user.h
+++ b/src/nspawn/nspawn-bind-user.h
@@ -3,4 +3,27 @@
 
 #include "shared-forward.h"
 
-int bind_user_setup(const MachineBindUserContext *c, const char *root);
+typedef struct CustomMount CustomMount;
+
+typedef struct BindUserData {
+        /* The host's user/group records */
+        UserRecord *host_user;
+        GroupRecord *host_group;
+
+        /* The mapped records to place into the container */
+        UserRecord *payload_user;
+        GroupRecord *payload_group;
+} BindUserData;
+
+typedef struct BindUserContext {
+        BindUserData *data;
+        size_t n_data;
+} BindUserContext;
+
+BindUserContext* bind_user_context_free(BindUserContext *c);
+
+DEFINE_TRIVIAL_CLEANUP_FUNC(BindUserContext*, bind_user_context_free);
+
+int bind_user_prepare(const char *directory, char **bind_user, const char *bind_user_shell, bool bind_user_shell_copy, uid_t uid_shift, uid_t uid_range, CustomMount **custom_mounts, size_t *n_custom_mounts, BindUserContext **ret);
+
+int bind_user_setup(const BindUserContext *c, const char *root);
diff --git a/src/nspawn/nspawn-mount.c b/src/nspawn/nspawn-mount.c
index a996b28fce..5b5294c5e9 100644
--- a/src/nspawn/nspawn-mount.c
+++ b/src/nspawn/nspawn-mount.c
@@ -25,7 +25,6 @@
 #include "string-util.h"
 #include "strv.h"
 #include "tmpfile-util.h"
-#include "user-util.h"
 
 CustomMount* custom_mount_add(CustomMount **l, size_t *n, CustomMountType t) {
         CustomMount *ret;
@@ -42,8 +41,7 @@ CustomMount* custom_mount_add(CustomMount **l, size_t *n, CustomMountType t) {
         (*n)++;
 
         *ret = (CustomMount) {
-                .type = t,
-                .destination_uid = UID_INVALID,
+                .type = t
         };
 
         return ret;
@@ -814,20 +812,9 @@ static int mount_bind(const char *dest, CustomMount *m, uid_t uid_shift, uid_t u
                         return r;
         }
 
-        /* ID remapping cannot be done if user namespaces are not in use (uid_shift is UID_INVALID).
-         * Fail if idmapping was explicitly requested in this state. Otherwise, treat UID_INVALID
-         * as 0 for ownership operations. */
-        if (idmapping != REMOUNT_IDMAPPING_NONE && !uid_is_valid(uid_shift))
-                return log_error_errno(
-                                SYNTHETIC_ERRNO(EINVAL),
-                                "ID remapping requested for %s, but user namespacing is not enabled.",
-                                m->source);
-
-        uid_t chown_uid = uid_is_valid(uid_shift) ? uid_shift : 0;
-
         /* If this is a bind mount from a temporary sources change ownership of the source to the container's
          * root UID. Otherwise it would always show up as "nobody" if user namespacing is used. */
-        if (m->rm_rf_tmpdir && chown(m->source, chown_uid, chown_uid) < 0)
+        if (m->rm_rf_tmpdir && chown(m->source, uid_shift, uid_shift) < 0)
                 return log_error_errno(errno, "Failed to chown %s: %m", m->source);
 
         /* UID/GIDs of idmapped mounts are always resolved in the caller's user namespace. In other
@@ -861,7 +848,7 @@ static int mount_bind(const char *dest, CustomMount *m, uid_t uid_shift, uid_t u
                 if (stat(where, &dest_st) < 0)
                         return log_error_errno(errno, "Failed to stat %s: %m", where);
 
-                dest_uid = uid_is_valid(m->destination_uid) ? chown_uid + m->destination_uid : dest_st.st_uid;
+                dest_uid = dest_st.st_uid;
 
                 if (S_ISDIR(source_st.st_mode) && !S_ISDIR(dest_st.st_mode))
                         return log_error_errno(SYNTHETIC_ERRNO(EINVAL),
@@ -874,7 +861,7 @@ static int mount_bind(const char *dest, CustomMount *m, uid_t uid_shift, uid_t u
                                                m->source, where);
 
         } else { /* Path doesn't exist yet? */
-                r = mkdir_parents_safe_label(dest, where, 0755, chown_uid, chown_uid, MKDIR_IGNORE_EXISTING);
+                r = mkdir_parents_safe_label(dest, where, 0755, uid_shift, uid_shift, MKDIR_IGNORE_EXISTING);
                 if (r < 0)
                         return log_error_errno(r, "Failed to make parents of %s: %m", where);
 
@@ -889,10 +876,10 @@ static int mount_bind(const char *dest, CustomMount *m, uid_t uid_shift, uid_t u
                 if (r < 0)
                         return log_error_errno(r, "Failed to create mount point %s: %m", where);
 
-                if (chown(where, chown_uid, chown_uid) < 0)
+                if (chown(where, uid_shift, uid_shift) < 0)
                         return log_error_errno(errno, "Failed to chown %s: %m", where);
 
-                dest_uid = chown_uid + (uid_is_valid(m->destination_uid) ? m->destination_uid : 0);
+                dest_uid = uid_shift;
         }
 
         if (move_mount(fd_clone, "", AT_FDCWD, where, MOVE_MOUNT_F_EMPTY_PATH) < 0)
diff --git a/src/nspawn/nspawn-mount.h b/src/nspawn/nspawn-mount.h
index 421c5dffff..eca85cdbfc 100644
--- a/src/nspawn/nspawn-mount.h
+++ b/src/nspawn/nspawn-mount.h
@@ -38,7 +38,6 @@ typedef struct CustomMount {
         bool read_only;
         char *source; /* for overlayfs this is the upper directory */
         char *destination;
-        uid_t destination_uid;
         char *options;
         char *work_dir;
         char **lower;
diff --git a/src/nspawn/nspawn.c b/src/nspawn/nspawn.c
index e4fccaa3a7..3bae84c81a 100644
--- a/src/nspawn/nspawn.c
+++ b/src/nspawn/nspawn.c
@@ -31,6 +31,7 @@
 #include "capability-list.h"
 #include "capability-util.h"
 #include "cgroup-setup.h"
+#include "cgroup-util.h"
 #include "chase.h"
 #include "common-signal.h"
 #include "constants.h"
@@ -52,6 +53,7 @@
 #include "format-util.h"
 #include "fs-util.h"
 #include "gpt.h"
+#include "group-record.h"
 #include "hexdecoct.h"
 #include "hostname-setup.h"
 #include "hostname-util.h"
@@ -63,7 +65,6 @@
 #include "log.h"
 #include "loop-util.h"
 #include "loopback-setup.h"
-#include "machine-bind-user.h"
 #include "machine-credential.h"
 #include "main-func.h"
 #include "mkdir.h"
@@ -242,7 +243,6 @@ static MachineCredentialContext arg_credentials = {};
 static char **arg_bind_user = NULL;
 static char *arg_bind_user_shell = NULL;
 static bool arg_bind_user_shell_copy = false;
-static char **arg_bind_user_groups = NULL;
 static bool arg_suppress_sync = false;
 static char *arg_settings_filename = NULL;
 static Architecture arg_architecture = _ARCHITECTURE_INVALID;
@@ -286,7 +286,6 @@ STATIC_DESTRUCTOR_REGISTER(arg_cpu_set, cpu_set_done);
 STATIC_DESTRUCTOR_REGISTER(arg_sysctl, strv_freep);
 STATIC_DESTRUCTOR_REGISTER(arg_bind_user, strv_freep);
 STATIC_DESTRUCTOR_REGISTER(arg_bind_user_shell, freep);
-STATIC_DESTRUCTOR_REGISTER(arg_bind_user_groups, strv_freep);
 STATIC_DESTRUCTOR_REGISTER(arg_settings_filename, freep);
 STATIC_DESTRUCTOR_REGISTER(arg_image_policy, image_policy_freep);
 STATIC_DESTRUCTOR_REGISTER(arg_background, freep);
@@ -433,8 +432,6 @@ static int help(void) {
                "     --bind-user=NAME       Bind user from host to container\n"
                "     --bind-user-shell=BOOL|PATH\n"
                "                            Configure the shell to use for --bind-user= users\n"
-               "     --bind-user-group=GROUP\n"
-               "                            Add an auxiliary group to --bind-user= users\n"
                "\n%3$sInput/Output:%4$s\n"
                "     --console=MODE         Select how stdin/stdout/stderr and /dev/console are\n"
                "                            set up for the container.\n"
@@ -666,7 +663,6 @@ static int parse_argv(int argc, char *argv[]) {
                 ARG_LOAD_CREDENTIAL,
                 ARG_BIND_USER,
                 ARG_BIND_USER_SHELL,
-                ARG_BIND_USER_GROUP,
                 ARG_SUPPRESS_SYNC,
                 ARG_IMAGE_POLICY,
                 ARG_BACKGROUND,
@@ -745,7 +741,6 @@ static int parse_argv(int argc, char *argv[]) {
                 { "load-credential",        required_argument, NULL, ARG_LOAD_CREDENTIAL        },
                 { "bind-user",              required_argument, NULL, ARG_BIND_USER              },
                 { "bind-user-shell",        required_argument, NULL, ARG_BIND_USER_SHELL        },
-                { "bind-user-group",        required_argument, NULL, ARG_BIND_USER_GROUP        },
                 { "suppress-sync",          required_argument, NULL, ARG_SUPPRESS_SYNC          },
                 { "image-policy",           required_argument, NULL, ARG_IMAGE_POLICY           },
                 { "background",             required_argument, NULL, ARG_BACKGROUND             },
@@ -1520,15 +1515,6 @@ static int parse_argv(int argc, char *argv[]) {
                         break;
                 }
 
-                case ARG_BIND_USER_GROUP:
-                        if (!valid_user_group_name(optarg, /* flags= */ 0))
-                                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Invalid bind user auxiliary group name: %s", optarg);
-
-                        if (strv_extend(&arg_bind_user_groups, optarg) < 0)
-                                return log_oom();
-
-                        break;
-
                 case ARG_SUPPRESS_SYNC:
                         r = parse_boolean_argument("--suppress-sync=", optarg, &arg_suppress_sync);
                         if (r < 0)
@@ -1704,16 +1690,15 @@ static int verify_arguments(void) {
                         return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "AmbientCapability= setting is not useful for boot mode.");
         }
 
-        /* Drop duplicate --bind-user= and --bind-user-group= entries */
+        if (arg_userns_mode == USER_NAMESPACE_NO && !strv_isempty(arg_bind_user))
+                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "--bind-user= requires --private-users");
+
+        /* Drop duplicate --bind-user= entries */
         strv_uniq(arg_bind_user);
-        strv_uniq(arg_bind_user_groups);
 
         if (arg_bind_user_shell && strv_isempty(arg_bind_user))
                 return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Cannot use --bind-user-shell= without --bind-user=");
 
-        if (!strv_isempty(arg_bind_user_groups) && strv_isempty(arg_bind_user))
-                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Cannot use --bind-user-group= without --bind-user=");
-
         r = custom_mount_check_all();
         if (r < 0)
                 return r;
@@ -2687,7 +2672,6 @@ static int setup_journal(const char *directory, uid_t uid_shift, uid_t uid_range
                                 .options = (char*) (uid_is_valid(uid_shift) ? "rootidmap" : NULL),
                                 .source = p,
                                 .destination = p,
-                                .destination_uid = UID_INVALID,
                         },
                         /* n= */ 1,
                         uid_shift,
@@ -3871,6 +3855,7 @@ static int outer_child(
                 int netns_fd,
                 const char *unix_export_path) {
 
+        _cleanup_(bind_user_context_freep) BindUserContext *bind_user_context = NULL;
         _cleanup_strv_free_ char **os_release_pairs = NULL;
         bool idmap = false;
         ssize_t l;
@@ -4035,43 +4020,38 @@ static int outer_child(
         if (r < 0)
                 return r;
 
-        _cleanup_(machine_bind_user_context_freep) MachineBindUserContext *bind_user_context = NULL;
-        r = machine_bind_user_prepare(
+        r = bind_user_prepare(
                         directory,
                         arg_bind_user,
                         arg_bind_user_shell,
                         arg_bind_user_shell_copy,
-                        "/run/host/home",
-                        arg_bind_user_groups,
+                        chown_uid,
+                        chown_range,
+                        &arg_custom_mounts, &arg_n_custom_mounts,
                         &bind_user_context);
         if (r < 0)
                 return r;
 
-        if (bind_user_context)
-                FOREACH_ARRAY(bind_user, bind_user_context->data, bind_user_context->n_data) {
-                        _cleanup_free_ char *sm = strdup(user_record_home_directory(bind_user->host_user));
-                        if (!sm)
-                                return log_oom();
-
-                        _cleanup_free_ char *sd = strdup(user_record_home_directory(bind_user->payload_user));
-                        if (!sd)
-                                return log_oom();
-
-                        if (!GREEDY_REALLOC(arg_custom_mounts, arg_n_custom_mounts + 1))
-                                return log_oom();
-
-                        char *options = strdup("owneridmap");
-                        if (!options)
-                                return log_oom();
+        if (arg_userns_mode != USER_NAMESPACE_NO && bind_user_context) {
+                /* Send the user maps we determined to the parent, so that it installs it in our user
+                 * namespace UID map table */
 
-                        arg_custom_mounts[arg_n_custom_mounts++] = (CustomMount) {
-                                .type = CUSTOM_MOUNT_BIND,
-                                .source = TAKE_PTR(sm),
-                                .destination = TAKE_PTR(sd),
-                                .options = TAKE_PTR(options),
-                                .destination_uid = bind_user->payload_user->uid,
+                FOREACH_ARRAY(d, bind_user_context->data, bind_user_context->n_data) {
+                        uid_t map[] = {
+                                d->payload_user->uid,
+                                d->host_user->uid,
+                                (uid_t) d->payload_group->gid,
+                                (uid_t) d->host_group->gid,
                         };
+
+                        l = send(fd_outer_socket, map, sizeof(map), MSG_NOSIGNAL);
+                        if (l < 0)
+                                return log_error_errno(errno, "Failed to send user UID map: %m");
+                        if (l != sizeof(map))
+                                return log_error_errno(SYNTHETIC_ERRNO(EIO),
+                                                       "Short write while sending user UID map.");
                 }
+        }
 
         r = mount_custom(
                         directory,
@@ -4492,6 +4472,69 @@ static int uid_shift_pick(uid_t *shift, LockFile *ret_lock_file) {
         }
 }
 
+static int add_one_uid_map(
+                char **p,
+                uid_t container_uid,
+                uid_t host_uid,
+                uid_t range) {
+
+        return strextendf(p,
+                       UID_FMT " " UID_FMT " " UID_FMT "\n",
+                       container_uid, host_uid, range);
+}
+
+static int make_uid_map_string(
+                const uid_t bind_user_uid[],
+                size_t n_bind_user_uid,
+                size_t offset,
+                char **ret) {
+
+        _cleanup_free_ char *s = NULL;
+        uid_t previous_uid = 0;
+        int r;
+
+        assert(n_bind_user_uid == 0 || bind_user_uid);
+        assert(IN_SET(offset, 0, 2)); /* used to switch between UID and GID map */
+        assert(ret);
+
+        /* The bind_user_uid[] array is a series of 4 uid_t values, for each --bind-user= entry one
+         * quadruplet, consisting of host and container UID + GID. */
+
+        for (size_t i = 0; i < n_bind_user_uid; i++) {
+                uid_t payload_uid = bind_user_uid[i*4+offset],
+                        host_uid = bind_user_uid[i*4+offset+1];
+
+                assert(previous_uid <= payload_uid);
+                assert(payload_uid < arg_uid_range);
+
+                /* Add a range to close the gap to previous entry */
+                if (payload_uid > previous_uid) {
+                        r = add_one_uid_map(&s, previous_uid, arg_uid_shift + previous_uid, payload_uid - previous_uid);
+                        if (r < 0)
+                                return r;
+                }
+
+                /* Map this specific user */
+                r = add_one_uid_map(&s, payload_uid, host_uid, 1);
+                if (r < 0)
+                        return r;
+
+                previous_uid = payload_uid + 1;
+        }
+
+        /* And add a range to close the gap to finish the range */
+        if (arg_uid_range > previous_uid) {
+                r = add_one_uid_map(&s, previous_uid, arg_uid_shift + previous_uid, arg_uid_range - previous_uid);
+                if (r < 0)
+                        return r;
+        }
+
+        assert(s);
+
+        *ret = TAKE_PTR(s);
+        return 0;
+}
+
 static int setup_uid_map(
                 const PidRef *pid,
                 const uid_t bind_user_uid[],
@@ -4504,7 +4547,8 @@ static int setup_uid_map(
         assert(pidref_is_set(pid));
         assert(pid->pid > 1);
 
-        if (asprintf(&s, "0 " UID_FMT " " UID_FMT "\n", arg_uid_shift, arg_uid_range) < 0)
+        /* Build the UID map string */
+        if (make_uid_map_string(bind_user_uid, n_bind_user_uid, 0, &s) < 0) /* offset=0 contains the UID pair */
                 return log_oom();
 
         xsprintf(uid_map, "/proc/" PID_FMT "/uid_map", pid->pid);
@@ -4512,6 +4556,11 @@ static int setup_uid_map(
         if (r < 0)
                 return log_error_errno(r, "Failed to write UID map: %m");
 
+        /* And now build the GID map string */
+        s = mfree(s);
+        if (make_uid_map_string(bind_user_uid, n_bind_user_uid, 2, &s) < 0) /* offset=2 contains the GID pair */
+                return log_oom();
+
         xsprintf(uid_map, "/proc/" PID_FMT "/gid_map", pid->pid);
         r = write_string_file(uid_map, s, WRITE_STRING_FILE_DISABLE_BUFFER);
         if (r < 0)
@@ -5267,6 +5316,26 @@ static int run_container(
                         if (l != sizeof arg_uid_shift)
                                 return log_error_errno(SYNTHETIC_ERRNO(EIO), "Short write while writing UID shift.");
                 }
+
+                n_bind_user_uid = strv_length(arg_bind_user);
+                if (n_bind_user_uid > 0) {
+                        /* Right after the UID shift, we'll receive the list of UID mappings for the
+                         * --bind-user= logic. Always a quadruplet of payload and host UID + GID. */
+
+                        bind_user_uid = new(uid_t, n_bind_user_uid*4);
+                        if (!bind_user_uid)
+                                return log_oom();
+
+                        for (size_t i = 0; i < n_bind_user_uid; i++) {
+                                l = recv(fd_outer_socket_pair[0], bind_user_uid + i*4, sizeof(uid_t)*4, 0);
+                                if (l < 0)
+                                        return log_error_errno(errno, "Failed to read user UID map pair: %m");
+                                if (l != sizeof(uid_t)*4)
+                                        return log_full_errno(l == 0 ? LOG_DEBUG : LOG_WARNING,
+                                                              SYNTHETIC_ERRNO(EIO),
+                                                              "Short read while reading bind user UID pairs.");
+                        }
+                }
         }
 
         /* Wait for the outer child. */
diff --git a/src/shared/machine-bind-user.c b/src/shared/machine-bind-user.c
deleted file mode 100644
index 278f7c99d0..0000000000
--- a/src/shared/machine-bind-user.c
+++ /dev/null
@@ -1,319 +0,0 @@
-/* SPDX-License-Identifier: LGPL-2.1-or-later */
-
-#include <grp.h>
-#include <pwd.h>
-
-#include "alloc-util.h"
-#include "chase.h"
-#include "fd-util.h"
-#include "format-util.h"
-#include "json-util.h"
-#include "log.h"
-#include "machine-bind-user.h"
-#include "path-util.h"
-#include "string-util.h"
-#include "strv.h"
-#include "user-util.h"
-#include "userdb.h"
-
-static int check_etc_passwd_collisions(
-                const char *directory,
-                const char *name,
-                uid_t uid) {
-
-        _cleanup_fclose_ FILE *f = NULL;
-        int r;
-
-        assert(name || uid_is_valid(uid));
-
-        if (!directory)
-                return 0;
-
-        r = chase_and_fopen_unlocked("/etc/passwd", directory, CHASE_PREFIX_ROOT, "re", NULL, &f);
-        if (r == -ENOENT)
-                return 0; /* no user database? then no user, hence no collision */
-        if (r < 0)
-                return log_error_errno(r, "Failed to open /etc/passwd of machine: %m");
-
-        for (;;) {
-                struct passwd *pw;
-
-                r = fgetpwent_sane(f, &pw);
-                if (r < 0)
-                        return log_error_errno(r, "Failed to iterate through /etc/passwd of machine: %m");
-                if (r == 0) /* EOF */
-                        return 0; /* no collision */
-
-                if (name && streq_ptr(pw->pw_name, name))
-                        return 1; /* name collision */
-                if (uid_is_valid(uid) && pw->pw_uid == uid)
-                        return 1; /* UID collision */
-        }
-}
-
-static int check_etc_group_collisions(
-                const char *directory,
-                const char *name,
-                gid_t gid) {
-
-        _cleanup_fclose_ FILE *f = NULL;
-        int r;
-
-        assert(name || gid_is_valid(gid));
-
-        if (!directory)
-                return 0;
-
-        r = chase_and_fopen_unlocked("/etc/group", directory, CHASE_PREFIX_ROOT, "re", NULL, &f);
-        if (r == -ENOENT)
-                return 0; /* no group database? then no group, hence no collision */
-        if (r < 0)
-                return log_error_errno(r, "Failed to open /etc/group of machine: %m");
-
-        for (;;) {
-                struct group *gr;
-
-                r = fgetgrent_sane(f, &gr);
-                if (r < 0)
-                        return log_error_errno(r, "Failed to iterate through /etc/group of machine: %m");
-                if (r == 0)
-                        return 0; /* no collision */
-
-                if (name && streq_ptr(gr->gr_name, name))
-                        return 1; /* name collision */
-                if (gid_is_valid(gid) && gr->gr_gid == gid)
-                        return 1; /* gid collision */
-        }
-}
-
-static int convert_user(
-                const char *directory,
-                UserRecord *u,
-                GroupRecord *g,
-                uid_t allocate_uid,
-                const char *shell,
-                bool shell_copy,
-                const char *home_mount_directory,
-                char **groups,
-                UserRecord **ret_converted_user,
-                GroupRecord **ret_converted_group) {
-
-        _cleanup_(group_record_unrefp) GroupRecord *converted_group = NULL;
-        _cleanup_(user_record_unrefp) UserRecord *converted_user = NULL;
-        _cleanup_free_ char *h = NULL;
-        sd_json_variant *p, *hp = NULL, *ssh = NULL;
-        int r;
-
-        assert(u);
-        assert(g);
-        assert(user_record_gid(u) == g->gid);
-
-        if (shell_copy)
-                shell = u->shell;
-
-        r = check_etc_passwd_collisions(directory, u->user_name, UID_INVALID);
-        if (r < 0)
-                return r;
-        if (r > 0)
-                return log_error_errno(SYNTHETIC_ERRNO(EBUSY),
-                                       "Sorry, the user '%s' already exists in the machine.", u->user_name);
-
-        r = check_etc_group_collisions(directory, g->group_name, GID_INVALID);
-        if (r < 0)
-                return r;
-        if (r > 0)
-                return log_error_errno(SYNTHETIC_ERRNO(EBUSY),
-                                       "Sorry, the group '%s' already exists in the machine.", g->group_name);
-
-        h = path_join(home_mount_directory, u->user_name);
-        if (!h)
-                return log_oom();
-
-        /* Acquire the source hashed password array as-is, so that it retains the JSON_VARIANT_SENSITIVE flag */
-        p = sd_json_variant_by_key(u->json, "privileged");
-        if (p) {
-                hp = sd_json_variant_by_key(p, "hashedPassword");
-                ssh = sd_json_variant_by_key(p, "sshAuthorizedKeys");
-        }
-
-        r = user_record_build(
-                        &converted_user,
-                        SD_JSON_BUILD_OBJECT(
-                                        SD_JSON_BUILD_PAIR_STRING("userName", u->user_name),
-                                        SD_JSON_BUILD_PAIR_UNSIGNED("uid", allocate_uid),
-                                        SD_JSON_BUILD_PAIR_UNSIGNED("gid", allocate_uid),
-                                        SD_JSON_BUILD_PAIR_CONDITION(u->disposition >= 0, "disposition", SD_JSON_BUILD_STRING(user_disposition_to_string(u->disposition))),
-                                        SD_JSON_BUILD_PAIR_STRING("homeDirectory", h),
-                                        SD_JSON_BUILD_PAIR("service", JSON_BUILD_CONST_STRING("io.systemd.NSpawn")),
-                                        JSON_BUILD_PAIR_STRING_NON_EMPTY("shell", shell),
-                                        SD_JSON_BUILD_PAIR_STRV("memberOf", groups),
-                                        SD_JSON_BUILD_PAIR("privileged", SD_JSON_BUILD_OBJECT(
-                                                                           SD_JSON_BUILD_PAIR_CONDITION(!strv_isempty(u->hashed_password), "hashedPassword", SD_JSON_BUILD_VARIANT(hp)),
-                                                                           SD_JSON_BUILD_PAIR_CONDITION(!!ssh, "sshAuthorizedKeys", SD_JSON_BUILD_VARIANT(ssh))))));
-        if (r < 0)
-                return log_error_errno(r, "Failed to build machine user record: %m");
-
-        r = group_record_build(
-                        &converted_group,
-                        SD_JSON_BUILD_OBJECT(
-                                        SD_JSON_BUILD_PAIR_STRING("groupName", g->group_name),
-                                        SD_JSON_BUILD_PAIR_UNSIGNED("gid", allocate_uid),
-                                        SD_JSON_BUILD_PAIR_CONDITION(g->disposition >= 0, "disposition", SD_JSON_BUILD_STRING(user_disposition_to_string(g->disposition))),
-                                        SD_JSON_BUILD_PAIR("service", JSON_BUILD_CONST_STRING("io.systemd.NSpawn"))));
-        if (r < 0)
-                return log_error_errno(r, "Failed to build machine group record: %m");
-
-        *ret_converted_user = TAKE_PTR(converted_user);
-        *ret_converted_group = TAKE_PTR(converted_group);
-
-        return 0;
-}
-
-static int find_free_uid(const char *directory, uid_t *current_uid) {
-        int r;
-
-        assert(current_uid);
-
-        for (;; (*current_uid)++) {
-                if (*current_uid > MAP_UID_MAX)
-                        return log_error_errno(
-                                        SYNTHETIC_ERRNO(EBUSY),
-                                        "No suitable available UID in range " UID_FMT "…" UID_FMT " in machine detected, can't map user.",
-                                        MAP_UID_MIN, MAP_UID_MAX);
-
-                r = check_etc_passwd_collisions(directory, NULL, *current_uid);
-                if (r < 0)
-                        return r;
-                if (r > 0) /* already used */
-                        continue;
-
-                /* We want to use the UID also as GID, hence check for it in /etc/group too */
-                r = check_etc_group_collisions(directory, NULL, (gid_t) *current_uid);
-                if (r <= 0)
-                        return r;
-        }
-}
-
-MachineBindUserContext* machine_bind_user_context_free(MachineBindUserContext *c) {
-        if (!c)
-                return NULL;
-
-        FOREACH_ARRAY(d, c->data, c->n_data) {
-                user_record_unref(d->host_user);
-                group_record_unref(d->host_group);
-                user_record_unref(d->payload_user);
-                group_record_unref(d->payload_group);
-        }
-
-        return mfree(c);
-}
-
-int machine_bind_user_prepare(
-                const char *directory,
-                char **bind_user,
-                const char *bind_user_shell,
-                bool bind_user_shell_copy,
-                const char *bind_user_home_mount_directory,
-                char **bind_user_groups,
-                MachineBindUserContext **ret) {
-
-        _cleanup_(machine_bind_user_context_freep) MachineBindUserContext *c = NULL;
-        uid_t current_uid = MAP_UID_MIN;
-        int r;
-
-        assert(ret);
-
-        /* This resolves the users specified in 'bind_user', generates a minimalized JSON user + group record
-         * for it to stick in the machine, allocates a UID/GID for it, and updates the custom mount table,
-         * to include an appropriate bind mount mapping.
-         *
-         * This extends the passed custom_mounts/n_custom_mounts with the home directories, and allocates a
-         * new BindUserContext for the user records */
-
-        if (strv_isempty(bind_user)) {
-                *ret = NULL;
-                return 0;
-        }
-
-        c = new0(MachineBindUserContext, 1);
-        if (!c)
-                return log_oom();
-
-        STRV_FOREACH(n, bind_user) {
-                _cleanup_(user_record_unrefp) UserRecord *u = NULL, *cu = NULL;
-                _cleanup_(group_record_unrefp) GroupRecord *g = NULL, *cg = NULL;
-
-                r = userdb_by_name(*n, /* match= */ NULL, USERDB_DONT_SYNTHESIZE_INTRINSIC|USERDB_DONT_SYNTHESIZE_FOREIGN, &u);
-                if (r == -ENOEXEC)
-                        return log_error_errno(r, "User '%s' did not pass filter.", *n);
-                if (r < 0)
-                        return log_error_errno(r, "Failed to resolve user '%s': %s", *n, STRERROR_USER(r));
-
-                /* For now, let's refuse mapping the root/nobody users explicitly. The records we generate
-                 * are strictly additive, nss-systemd is typically placed last in /etc/nsswitch.conf. Thus
-                 * even if we wanted, we couldn't override the root or nobody user records. Note we also
-                 * check for name conflicts in /etc/passwd + /etc/group later on, which would usually filter
-                 * out root/nobody too, hence these checks might appear redundant — but they actually are
-                 * not, as we want to support environments where /etc/passwd and /etc/group are non-existent,
-                 * and the user/group databases fully synthesized at runtime. Moreover, the name of the
-                 * user/group name of the "nobody" account differs between distros, hence a check by numeric
-                 * UID is safer. */
-                if (user_record_is_root(u))
-                        return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Mapping 'root' user not supported, sorry.");
-
-                if (user_record_is_nobody(u))
-                        return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Mapping 'nobody' user not supported, sorry.");
-
-                if (!uid_is_valid(u->uid))
-                        return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Cannot bind user with no UID, refusing.");
-
-                r = groupdb_by_gid(user_record_gid(u), /* match= */ NULL, USERDB_DONT_SYNTHESIZE_INTRINSIC|USERDB_DONT_SYNTHESIZE_FOREIGN, &g);
-                if (r == -ENOEXEC)
-                        return log_error_errno(r, "Group of user '%s' did not pass filter.", u->user_name);
-                if (r < 0)
-                        return log_error_errno(r, "Failed to resolve group of user '%s': %s",
-                                               u->user_name, STRERROR_GROUP(r));
-
-                /* We want to synthesize exactly one user + group from the host into the machine. This only
-                 * makes sense if the user on the host has its own private group. We can't reasonably check
-                 * this, so we just check of the name of user and group match.
-                 *
-                 * One of these days we might want to support users in a shared/common group too, but it's
-                 * not clear to me how this would have to be mapped, precisely given that the common group
-                 * probably already exists in the machine. */
-                if (!streq(u->user_name, g->group_name))
-                        return log_error_errno(SYNTHETIC_ERRNO(EOPNOTSUPP),
-                                               "Sorry, mapping users without private groups is currently not supported.");
-
-                r = find_free_uid(directory, &current_uid);
-                if (r < 0)
-                        return r;
-
-                r = convert_user(
-                                directory,
-                                u, g,
-                                current_uid,
-                                bind_user_shell,
-                                bind_user_shell_copy,
-                                bind_user_home_mount_directory,
-                                bind_user_groups,
-                                &cu, &cg);
-                if (r < 0)
-                        return r;
-
-                if (!GREEDY_REALLOC(c->data, c->n_data + 1))
-                        return log_oom();
-
-                c->data[c->n_data++] = (MachineBindUserData) {
-                        .host_user = TAKE_PTR(u),
-                        .host_group = TAKE_PTR(g),
-                        .payload_user = TAKE_PTR(cu),
-                        .payload_group = TAKE_PTR(cg),
-                };
-
-                current_uid++;
-        }
-
-        *ret = TAKE_PTR(c);
-        return 1;
-}
diff --git a/src/shared/machine-bind-user.h b/src/shared/machine-bind-user.h
deleted file mode 100644
index 265fe13727..0000000000
--- a/src/shared/machine-bind-user.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/* SPDX-License-Identifier: LGPL-2.1-or-later */
-#pragma once
-
-#include "shared-forward.h"
-
-typedef struct MachineBindUserData {
-        /* The host's user/group records */
-        UserRecord *host_user;
-        GroupRecord *host_group;
-
-        /* The mapped records to place into the container */
-        UserRecord *payload_user;
-        GroupRecord *payload_group;
-} MachineBindUserData;
-
-typedef struct MachineBindUserContext {
-        MachineBindUserData *data;
-        size_t n_data;
-} MachineBindUserContext;
-
-MachineBindUserContext* machine_bind_user_context_free(MachineBindUserContext *c);
-
-DEFINE_TRIVIAL_CLEANUP_FUNC(MachineBindUserContext*, machine_bind_user_context_free);
-
-int machine_bind_user_prepare(
-                const char *directory,
-                char **bind_user,
-                const char *bind_user_shell,
-                bool bind_user_shell_copy,
-                const char *bind_user_home_mount_directory,
-                char **bind_user_groups,
-                MachineBindUserContext **ret);
diff --git a/src/shared/meson.build b/src/shared/meson.build
index e0b86e0b81..cd52fb746c 100644
--- a/src/shared/meson.build
+++ b/src/shared/meson.build
@@ -122,7 +122,6 @@ shared_sources = files(
         'loop-util.c',
         'loopback-setup.c',
         'lsm-util.c',
-        'machine-bind-user.c',
         'machine-credential.c',
         'machine-id-setup.c',
         'macvlan-util.c',
diff --git a/src/shared/shared-forward.h b/src/shared/shared-forward.h
index 3695d4e671..1257950d8d 100644
--- a/src/shared/shared-forward.h
+++ b/src/shared/shared-forward.h
@@ -68,8 +68,6 @@ typedef struct InstallChange InstallChange;
 typedef struct InstallInfo InstallInfo;
 typedef struct LookupPaths LookupPaths;
 typedef struct LoopDevice LoopDevice;
-typedef struct MachineBindUserContext MachineBindUserContext;
-typedef struct MachineCredentialContext MachineCredentialContext;
 typedef struct MountOptions MountOptions;
 typedef struct OpenFile OpenFile;
 typedef struct Pkcs11EncryptedKey Pkcs11EncryptedKey;
diff --git a/src/vmspawn/vmspawn.c b/src/vmspawn/vmspawn.c
index 52ed833948..86474049f8 100644
--- a/src/vmspawn/vmspawn.c
+++ b/src/vmspawn/vmspawn.c
@@ -143,7 +143,6 @@ static bool arg_notify_ready = true;
 static char **arg_bind_user = NULL;
 static char *arg_bind_user_shell = NULL;
 static bool arg_bind_user_shell_copy = false;
-static char **arg_bind_user_groups = NULL;
 
 STATIC_DESTRUCTOR_REGISTER(arg_directory, freep);
 STATIC_DESTRUCTOR_REGISTER(arg_image, freep);
@@ -165,7 +164,6 @@ STATIC_DESTRUCTOR_REGISTER(arg_tpm_state_path, freep);
 STATIC_DESTRUCTOR_REGISTER(arg_property, strv_freep);
 STATIC_DESTRUCTOR_REGISTER(arg_bind_user, strv_freep);
 STATIC_DESTRUCTOR_REGISTER(arg_bind_user_shell, freep);
-STATIC_DESTRUCTOR_REGISTER(arg_bind_user_groups, strv_freep);
 
 static int help(void) {
         _cleanup_free_ char *link = NULL;
@@ -229,8 +227,6 @@ static int help(void) {
                "     --bind-user=NAME       Bind user from host to virtual machine\n"
                "     --bind-user-shell=BOOL|PATH\n"
                "                            Configure the shell to use for --bind-user= users\n"
-               "     --bind-user-group=GROUP\n"
-               "                            Add an auxiliary group to --bind-user= users\n"
                "\n%3$sIntegration:%4$s\n"
                "     --forward-journal=FILE|DIR\n"
                "                           Forward the VM's journal to the host\n"
@@ -307,7 +303,6 @@ static int parse_argv(int argc, char *argv[]) {
                 ARG_NOTIFY_READY,
                 ARG_BIND_USER,
                 ARG_BIND_USER_SHELL,
-                ARG_BIND_USER_GROUP,
         };
 
         static const struct option options[] = {
@@ -359,7 +354,6 @@ static int parse_argv(int argc, char *argv[]) {
                 { "notify-ready",      required_argument, NULL, ARG_NOTIFY_READY      },
                 { "bind-user",         required_argument, NULL, ARG_BIND_USER         },
                 { "bind-user-shell",   required_argument, NULL, ARG_BIND_USER_SHELL   },
-                { "bind-user-group",   required_argument, NULL, ARG_BIND_USER_GROUP   },
                 {}
         };
 
@@ -721,15 +715,6 @@ static int parse_argv(int argc, char *argv[]) {
                         break;
                 }
 
-                case ARG_BIND_USER_GROUP:
-                        if (!valid_user_group_name(optarg, /* flags= */ 0))
-                                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Invalid bind user auxiliary group name: %s", optarg);
-
-                        if (strv_extend(&arg_bind_user_groups, optarg) < 0)
-                                return log_oom();
-
-                        break;
-
                 case '?':
                         return -EINVAL;
 
@@ -737,16 +722,12 @@ static int parse_argv(int argc, char *argv[]) {
                         assert_not_reached();
                 }
 
-        /* Drop duplicate --bind-user= and --bind-user-group= entries */
+        /* Drop duplicate --bind-user= entries */
         strv_uniq(arg_bind_user);
-        strv_uniq(arg_bind_user_groups);
 
         if (arg_bind_user_shell && strv_isempty(arg_bind_user))
                 return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Cannot use --bind-user-shell= without --bind-user=");
 
-        if (!strv_isempty(arg_bind_user_groups) && strv_isempty(arg_bind_user))
-                return log_error_errno(SYNTHETIC_ERRNO(EINVAL), "Cannot use --bind-user-group= without --bind-user=");
-
         if (argc > optind) {
                 arg_kernel_cmdline_extra = strv_copy(argv + optind);
                 if (!arg_kernel_cmdline_extra)
@@ -1859,7 +1840,6 @@ static int run_virtual_machine(int kvm_device_fd, int vhost_device_fd) {
                         arg_bind_user_shell,
                         arg_bind_user_shell_copy,
                         "/run/vmhost/home",
-                        arg_bind_user_groups,
                         &bind_user_context);
         if (r < 0)
                 return r;

base-commit: d72165a37f8647a3c0e970c4bd411271a1d3a280
-- 
2.52.0

